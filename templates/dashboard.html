{% extends "base.html" %}

{% block content %}
<style>
    .game-cell {
        position: relative; 
        overflow: hidden;
    }
    .bubble {
        position: absolute;
        border-radius: 50%;
        transition: all 0.3s ease;
        box-shadow: inset -2px -2px 4px rgba(0,0,0,0.2), 1px 1px 2px rgba(255,255,255,0.7);
        font-size: 20px;
    }
    .peasant { width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255, 255, 255, 0.8);}
    .mandarin {
        width: 60px; height: 60px;
        border: 2px solid rgba(255, 255, 255, 0.8);
        font-weight: bold; color: white;
        display: flex; align-items: center; justify-content: center;
        font-size: 30px;
    }
    .bubble-a { border-color: #3b82f6; } 
    .bubble-b { border-color: #16a34a; } 

    .human-turn .game-cell.selectable {
        cursor: pointer;
        outline: 4px dashed #f59e0b;
        outline-offset: -4px;
        animation: pulse 2s infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .flying-bubble {
        position: fixed; /* Fixed position to move across the whole screen */
        z-index: 100;
        transition: left 0.25s ease-out, top 0.25s ease-out;
    }
</style>

<div class="flex items-center justify-center w-full h-[100vh] p-4">
    <div class="flex gap-4 h-full w-full items-center justify-center">
        <div class="h-full w-[80%] bg-slate-700 shadow-md rounded-lg flex flex-col p-2 gap-2">
            <div class="flex justify-between items-center text-white px-2">
                <span id="game-status" class="font-bold text-lg">Loading...</span>
                <div class="flex gap-4 items-center">
                    <div id="scores" class="text-white flex gap-4">
                        <span>P1 (A): <strong id="score-a">0</strong></span>
                        <span>P2 (B): <strong id="score-b">0</strong></span>
                    </div>
                    <button id="move-btn" class="bg-green-600 hover:bg-green-700 text-white py-1 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">Move</button>
                    <button id="reset-btn" class="bg-red-600 hover:bg-red-700 text-white py-1 px-4 rounded">Reset</button>
                </div>
            </div>
            
            <div id="game_board" class="bg-gray-200 rounded h-full p-4 flex flex-col justify-around">
                 <div class="flex items-center gap-4">
                    <div id="QA" class="game-cell w-[120px] h-[120px] bg-blue-200 rounded-full flex flex-col items-center justify-center border-4 border-blue-400"></div>
                    <div class="flex-1 grid grid-cols-5 gap-4">
                        <div id="A1" class="game-cell h-[100px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A2" class="game-cell h-[100px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A3" class="game-cell h-[100px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A4" class="game-cell h-[100px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A5" class="game-cell h-[100px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                     <div class="flex-1 grid grid-cols-5 gap-4">
                        <div id="B1" class="game-cell h-[100px] bg-green-100 rounded-lg border-2 border-green-300"></div>
                        <div id="B2" class="game-cell h-[100px] bg-green-100 rounded-lg border-2 border-green-300"></div>
                        <div id="B3" class="game-cell h-[100px] bg-green-100 rounded-lg border-2 border-green-300"></div>
                        <div id="B4" class="game-cell h-[100px] bg-green-100 rounded-lg border-2 border-green-300"></div>
                        <div id="B5" class="game-cell h-[100px] bg-green-100 rounded-lg border-2 border-green-300"></div>
                    </div>
                    <div id="QB" class="game-cell w-[120px] h-[120px] bg-green-200 rounded-full flex flex-col items-center justify-center border-4 border-green-400"></div>
                </div>
            </div>

            <div id="history_board" class="bg-slate-800 p-4 rounded h-1/3 relative overflow-y-auto">
                <button id="open-history-btn" class="absolute top-2 right-2 text-white opacity-50 hover:opacity-100 focus:outline-none">L·ªãch s·ª≠ üìÑ</button>
                <div id="history-log" class="flex flex-col-reverse gap-3 text-white"></div>
            </div>
        </div>
        {% include "slidebar.html" %}
    </div>
</div>

<!-- Direction Choice Modal -->
<div id="direction-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
    <div class="bg-slate-700 text-white rounded-lg shadow-xl w-full max-w-sm text-center p-6">
        <h3 class="text-xl font-bold mb-6">Ch·ªçn h∆∞·ªõng ƒëi</h3>
        <div class="flex justify-around">
             <button data-way="left_to_right" class="direction-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">‚û°Ô∏è Ph·∫£i</button>
             <button data-way="right_to_left" class="direction-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg">‚¨ÖÔ∏è Tr√°i</button>
        </div>
    </div>
</div>

<!-- History Modal -->
<div id="history-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
    <div class="bg-slate-800 text-white rounded-lg shadow-xl w-full max-w-4xl h-full max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center p-4 border-b border-slate-600">
            <h3 class="text-xl font-bold">L·ªãch s·ª≠ v√°n ƒë·∫•u</h3>
            <button id="close-history-modal" class="text-3xl leading-none hover:text-red-500">&times;</button>
        </div>
        <div id="modal-history-content" class="p-4 overflow-y-auto flex flex-col-reverse gap-3">
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const moveBtn = document.getElementById('move-btn');
        const resetBtn = document.getElementById('reset-btn');
        const applyConfigBtn = document.getElementById('apply-config');
        const historyLog = document.getElementById('history-log');
        const gameBoard = document.getElementById('game_board');
        const directionModal = document.getElementById('direction-modal');
        const historyModal = document.getElementById('history-modal');
        const openHistoryBtn = document.getElementById('open-history-btn');
        const closeHistoryModalBtn = document.getElementById('close-history-modal');
        const modalHistoryContent = document.getElementById('modal-history-content');
        let selectedPos = null;

        const sleep = ms => new Promise(res => setTimeout(res, ms));

        async function fetchAPI(endpoint, method = 'GET', body = null) {
            const options = { method, headers: { 'Content-Type': 'application/json' } };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
                updateStatus(`Error connecting to server.`);
                return null;
            }
        }

        function createBubbleElement(piece) {
            const bubble = document.createElement('div');
            bubble.className = `bubble ${piece.startsWith('p') ? 'peasant' : 'mandarin'} ${piece.endsWith('_a') ? 'bubble-a' : 'bubble-b'}`;
            if (piece.startsWith('m')) {
                 bubble.textContent = 'üßô‚Äç‚ôÇÔ∏è';
            } else {
                bubble.textContent = 'üßë‚Äçüåæ';
            }
            return bubble;
        }

        function renderBubbles(cellElement, pieces) {
            cellElement.innerHTML = '';
            pieces.forEach(piece => {
                const bubble = createBubbleElement(piece);
                const size = piece.startsWith('p') ? 60 : 80;
                const padding = 5;
                bubble.style.left = `${padding + Math.random() * (cellElement.clientWidth - size - padding * 2)}px`;
                bubble.style.top = `${padding + Math.random() * (cellElement.clientHeight - size - padding * 2)}px`;
                cellElement.appendChild(bubble);
            });
        }

        function updateStatus(message) { document.getElementById('game-status').textContent = message; }
        
        function addHistoryEntry(action, round, animationEvents) {
            const entry = document.createElement('div');
            entry.className = 'p-2 rounded border border-slate-600 text-sm';
            
            let html = `<div class="flex justify-between items-center opacity-70"><span>Round ${round} - Player ${action.pos ? action.pos.charAt(0) : '?'}</span><span>${new Date().toLocaleTimeString()}</span></div><p class="font-semibold my-1">Move: ${action.pos || 'N/A'} -> ${action.way || 'N/A'}</p><div class="text-xs opacity-80 pl-2 border-l-2 border-slate-500 max-h-24 overflow-y-auto">`;
            
            if (animationEvents) {
                let dropCounter = 0;
                animationEvents.forEach(event => {
                    switch(event.type) {
                        case 'pickup':
                            dropCounter = 0;
                            html += `<div><strong>B·ªëc ${event.pieces.length} qu√¢n</strong> t·ª´ √¥ ${event.pos}</div>`;
                            break;
                        case 'drop':
                            dropCounter++;
                            let pieceType = event.piece.startsWith('p') ? 'D√¢n' : 'Quan';
                            html += `<div>&nbsp;&nbsp;‚Ü≥ R·∫£i qu√¢n ${pieceType} #${dropCounter} t·ªõi √¥ ${event.to_pos}</div>`;
                            break;
                        case 'capture':
                            html += `<div><strong>ƒÇn ${event.pieces.length} qu√¢n</strong> ·ªü √¥ ${event.pos}</div>`;
                            break;
                        case 'game_over':
                            html += `<div class="font-bold text-red-400">${event.message}</div>`;
                            break;
                    }
                });
            } else if (action.steps) {
                 action.steps.forEach(step => { html += `<div>${step}</div>`; });
            }
            
            html += `</div>`;
            entry.innerHTML = html;
            historyLog.prepend(entry);
        }

        function updateUI(data) {
            if (!data || !data.game_state) return;
            const { game_state, game_over, winner, next_turn, action_details, animation_events } = data;
            const { board, score, round } = game_state;
            document.getElementById('score-a').textContent = score.A;
            document.getElementById('score-b').textContent = score.B;
            Object.keys(board).forEach(pos => {
                const cell = document.getElementById(pos);
                if (cell) {
                    renderBubbles(cell, board[pos]);
                    cell.classList.remove('ring-4', 'ring-offset-2', 'ring-purple-500', 'ring-yellow-500', 'ring-red-500');
                }
            });
            if (game_over) {
                updateStatus(`Game Over! Winner: ${winner}. (Round ${round})`);
                moveBtn.disabled = true;
                setHumanInteraction(false);
            } else {
                updateStatus(`Round ${round} - Turn: Player ${next_turn}`);
                moveBtn.disabled = data.human_turn === true;
            }
            if (action_details) addHistoryEntry(action_details, round, animation_events);
        }

        // --- Animation Logic (REVISED) ---
        async function animateEvents(events, finalState) {
            setHumanInteraction(false);
            moveBtn.disabled = true;
            resetBtn.disabled = true;
            applyConfigBtn.disabled = true;

            let lastHighlightedCell = null;
            let currentPickupPos = null;

            for (const event of events) {
                if (event.type === 'pickup') {
                    if (lastHighlightedCell) {
                        lastHighlightedCell.classList.remove('ring-4', 'ring-yellow-500');
                    }
                    currentPickupPos = event.pos;
                    const pickupCell = document.getElementById(event.pos);
                    if (pickupCell) {
                        pickupCell.classList.add('ring-4', 'ring-yellow-500');
                        lastHighlightedCell = pickupCell;
                        await sleep(400);
                    }
                } else if (event.type === 'drop') {
                    await animateSingleDrop(currentPickupPos, event.to_pos, event.piece);
                } else if (event.type === 'capture') {
                    await animateCapture(event.pos, event.team);
                } else if (event.type === 'score_update') {
                    document.getElementById('score-a').textContent = event.score.A;
                    document.getElementById('score-b').textContent = event.score.B;
                    await sleep(300);
                } else if (event.type === 'game_over') {
                    await sleep(500);
                    alert(event.message);
                }
            }
            
            updateUI(finalState);
            
            resetBtn.disabled = false;
            applyConfigBtn.disabled = false;
        }

        function getElementCenter(el) {
            const rect = el.getBoundingClientRect();
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        async function animateSingleDrop(fromPos, toPos, piece) {
            const fromCell = document.getElementById(fromPos);
            const toCell = document.getElementById(toPos);
            if (!fromCell || !toCell) return;

            const bubbleToRemove = fromCell.querySelector('.bubble');
            let startRect;

            if (bubbleToRemove) {
                startRect = bubbleToRemove.getBoundingClientRect();
                fromCell.removeChild(bubbleToRemove);
            } else {
                const startCenter = getElementCenter(fromCell);
                startRect = { left: startCenter.x, top: startCenter.y, width: 0, height: 0 };
            }

            const endCenter = getElementCenter(toCell);
            
            const flyingBubble = createBubbleElement(piece);
            flyingBubble.classList.add('flying-bubble');
            document.body.appendChild(flyingBubble);
            
            flyingBubble.style.left = `${startRect.left}px`;
            flyingBubble.style.top = `${startRect.top}px`;

            await sleep(10);
            
            flyingBubble.style.left = `${endCenter.x - flyingBubble.offsetWidth / 2}px`;
            flyingBubble.style.top = `${endCenter.y - flyingBubble.offsetHeight / 2}px`;
            
            await sleep(250);
            document.body.removeChild(flyingBubble);
            
            toCell.appendChild(createBubbleElement(piece));
        }
        
        async function animateCapture(fromPos, team) {
            const fromCell = document.getElementById(fromPos);
            const scoreEl = document.getElementById(team === 'A' ? 'score-a' : 'score-b');
            
            fromCell.innerHTML = '';

            fromCell.classList.add('ring-4', 'ring-red-500', 'transition-all', 'duration-500');
            scoreEl.classList.add('scale-150', 'text-yellow-400', 'transition-all', 'duration-300');
            
            await sleep(500); 
            
            fromCell.classList.remove('ring-4', 'ring-red-500');
            scoreEl.classList.remove('scale-150', 'text-yellow-400');
        }

        function setHumanInteraction(enable, availablePos = []) {
            gameBoard.classList.toggle('human-turn', enable);
            document.querySelectorAll('.game-cell').forEach(cell => {
                cell.classList.remove('selectable');
                cell.onclick = null;
            });
            if (enable) {
                updateStatus('Your turn! Please select a cell.');
                availablePos.forEach(pos => {
                    const cell = document.getElementById(pos);
                    if (cell) {
                        cell.classList.add('selectable');
                        cell.onclick = () => handleCellClick(pos);
                    }
                });
            }
        }

        function handleCellClick(pos) {
            selectedPos = pos;
            directionModal.classList.remove('hidden');
        }

        async function handleDirectionChoice(way) {
            directionModal.classList.add('hidden');
            setHumanInteraction(false);
            updateStatus(`Moving from ${selectedPos}...`);
            const data = await fetchAPI('/api/human_move', 'POST', { pos: selectedPos, way });
            if (data && data.animation_events) {
                await animateEvents(data.animation_events, data);
            } else if (data) {
                updateUI(data);
            }
        }

        async function handleMove() {
            moveBtn.disabled = true;
            updateStatus('Thinking...');
            const data = await fetchAPI('/api/move', 'POST');
            if (data) {
                if (data.human_turn) {
                    updateUI(data);
                    setHumanInteraction(true, data.available_pos);
                } else if (data.animation_events) {
                    await animateEvents(data.animation_events, data);
                } else {
                    updateUI(data);
                }
            }
        }

        async function handleReset() {
            if (confirm('Are you sure you want to reset the game?')) {
                updateStatus('Resetting game...');
                const data = await fetchAPI('/api/reset', 'POST');
                if (data) {
                    historyLog.innerHTML = '';
                    modalHistoryContent.innerHTML = '';
                    updateUI(data);
                    alert('Game has been reset!');
                }
            }
        }

        async function handleApplyConfig() {
            const player1Type = document.getElementById('player1').value;
            const player2Type = document.getElementById('player2').value;
            const settings = {
                player1: {
                    type: player1Type,
                    model: player1Type === 'agent' ? document.getElementById('model-select-1')?.value : null,
                    temperature: player1Type === 'agent' ? parseFloat(document.getElementById('temperature-value-1')?.value) : null,
                    maxTokens: player1Type === 'agent' ? parseInt(document.getElementById('max-tokens-value-1')?.value) : null,
                    topP: player1Type === 'agent' ? parseFloat(document.getElementById('top-p-value-1')?.value) : null,
                    thinkingMode: player1Type === 'agent' ? document.getElementById('thinking-mode-1')?.checked : null,
                },
                player2: {
                    type: player2Type,
                    model: player2Type === 'agent' ? document.getElementById('model-select-2')?.value : null,
                    temperature: player2Type === 'agent' ? parseFloat(document.getElementById('temperature-value-2')?.value) : null,
                    maxTokens: player2Type === 'agent' ? parseInt(document.getElementById('max-tokens-value-2')?.value) : null,
                    topP: player2Type === 'agent' ? parseFloat(document.getElementById('top-p-value-2')?.value) : null,
                    thinkingMode: player2Type === 'agent' ? document.getElementById('thinking-mode-2')?.checked : null,
                },
            };
            
            const response = await fetchAPI('/api/settings', 'POST', settings);
            if(response) {
                alert(response.message);
                historyLog.innerHTML = '';
                modalHistoryContent.innerHTML = '';
                updateUI(response);
            }
        }
        
        function showHistoryModal() {
            modalHistoryContent.innerHTML = historyLog.innerHTML;
            historyModal.classList.remove('hidden');
        }
        function hideHistoryModal() { historyModal.classList.add('hidden'); }

        async function initialize() {
            updateStatus('Fetching initial game state...');
            const data = await fetchAPI('/api/state');
            if (data) updateUI(data);
        }
        
        moveBtn.addEventListener('click', handleMove);
        resetBtn.addEventListener('click', handleReset);
        applyConfigBtn.addEventListener('click', handleApplyConfig);
        document.querySelectorAll('.direction-btn').forEach(btn => {
            btn.addEventListener('click', () => handleDirectionChoice(btn.dataset.way));
        });
        openHistoryBtn.addEventListener('click', showHistoryModal);
        closeHistoryModalBtn.addEventListener('click', hideHistoryModal);
        historyModal.addEventListener('click', (event) => {
            if (event.target === historyModal) hideHistoryModal();
        });
        
        initialize();
    });
</script>
{% endblock %}
