{% extends "base.html" %}

{% block content %}
<style>
    .game-cell {
        position: relative;
        overflow: hidden;
    }

    .bubble {
        position: absolute;
        border-radius: 50%;
        transition: all 0.3s ease;
        box-shadow: inset -2px -2px 4px rgba(0, 0, 0, 0.2), 1px 1px 2px rgba(255, 255, 255, 0.7);
        font-size: 20px;
    }

    .peasant {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255, 255, 255, 0.8);
    }

    .mandarin {
        width: 60px;
        height: 60px;
        border: 2px solid rgba(255, 255, 255, 0.8);
        font-weight: bold;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 30px;
    }

    .bubble-a {
        border-color: #3b82f6;
    }

    .bubble-b {
        border-color: #16a34a;
    }

    .human-turn .game-cell.selectable {
        cursor: pointer;
        outline: 4px dashed #f59e0b;
        outline-offset: -4px;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.6;
        }
    }

    .flying-bubble {
        position: fixed;
        /* Fixed position to move across the whole screen */
        z-index: 100;
        transition: left 0.25s ease-out, top 0.25s ease-out;
    }
</style>

<div class="flex items-center justify-center w-full h-[100vh] p-4">
    <div class="flex gap-4 h-full w-full items-center justify-center">
        <div class="h-full w-[80%] bg-slate-700 shadow-md rounded-lg flex flex-col p-2 gap-1">
            <div class="flex justify-between items-center text-white px-2">
                <span id="game-status" class="font-bold text-lg">Loading...</span>
                <div class="flex gap-4 items-center">
                    <div id="scores" class="text-white flex gap-4">
                        <span>P1 (A): <strong id="score-a">0</strong></span>
                        <span>P2 (B): <strong id="score-b">0</strong></span>
                    </div>
                    <button id="move-btn"
                        class="bg-green-600 hover:bg-green-700 text-white py-1 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">Move</button>
                    <button id="reset-btn"
                        class="bg-red-600 hover:bg-red-700 text-white py-1 px-4 rounded">Reset</button>
                </div>
            </div>

            <div id="game_board" class="bg-gray-200 rounded h-full p-4 flex items-center justify-around gap-4 relative">
                <div id="animation-overlay" class="absolute inset-0 pointer-events-none hidden z-10"></div>
                <div id="QA"
                    class="game-cell w-1/5 h-[250px] bg-blue-200 rounded-lg flex items-center justify-center border-4 border-blue-400">
                </div>
                <div class="flex flex-col gap-4 w-full">
                    <div class="grid grid-cols-5 gap-4">
                        <div id="A1" class="game-cell h-[200px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A2" class="game-cell h-[200px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A3" class="game-cell h-[200px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A4" class="game-cell h-[200px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                        <div id="A5" class="game-cell h-[200px] bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                    </div>

                    <div class="grid grid-cols-5 gap-4">
                        <div id="B1" class="game-cell h-[200px] bg-pink-100 rounded-lg border-2 border-pink-300">
                        </div>
                        <div id="B2" class="game-cell h-[200px] bg-pink-100 rounded-lg border-2 border-pink-300">
                        </div>
                        <div id="B3" class="game-cell h-[200px] bg-pink-100 rounded-lg border-2 border-pink-300">
                        </div>
                        <div id="B4" class="game-cell h-[200px] bg-pink-100 rounded-lg border-2 border-pink-300">
                        </div>
                        <div id="B5" class="game-cell h-[200px] bg-pink-100 rounded-lg border-2 border-pink-300">
                        </div>
                    </div>
                </div>
                <div id="QB"
                    class="game-cell w-1/5 h-[250px] bg-pink-200 rounded-lg flex items-center justify-center border-4 border-pink-400">
                </div>
            </div>

            <div id="history_board" class="bg-slate-800 p-4 rounded h-1/3 relative overflow-y-auto">
                <button id="open-history-btn"
                    class="absolute top-2 right-2 text-white opacity-50 hover:opacity-100 focus:outline-none">
                    L·ªãch s·ª≠ üìÑ
                </button>
                <div id="history-log" class="flex flex-col-reverse gap-3 text-white"></div>
            </div>
        </div>
        {% include "slidebar.html" %}
    </div>
</div>

<div id="direction-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
    <div class="bg-slate-700 text-white rounded-lg shadow-xl w-full max-w-sm text-center p-6">
        <h3 class="text-xl font-bold mb-6">Ch·ªçn h∆∞·ªõng ƒëi</h3>
        <div class="flex justify-around gap-4" id="direction_box">
            <button data-way="counter_clockwise"
                class="direction-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                üîÑng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì
            </button>
            <button data-way="clockwise"
                class="direction-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                üîÅc√πng chi·ªÅu kim ƒë·ªìng h·ªì
            </button>
        </div>
    </div>
</div>

<div id="history-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
    <div class="bg-slate-800 text-white rounded-lg shadow-xl w-full max-w-4xl h-full max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center p-4 border-b border-slate-600">
            <h3 class="text-xl font-bold">L·ªãch s·ª≠ v√°n ƒë·∫•u</h3>
            <div class="flex items-center gap-2">
                <button id="export-history-json"
                    class="text-sm bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">
                    Export JSON
                </button>
                <button id="close-history-modal" class="text-3xl leading-none hover:text-red-500">&times;</button>
            </div>
        </div>
        <div id="modal-history-content" class="p-4 overflow-y-auto flex flex-col-reverse gap-3">
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const moveBtn = document.getElementById('move-btn');
        const resetBtn = document.getElementById('reset-btn');
        const applyConfigBtn = document.getElementById('apply-config');
        const historyLog = document.getElementById('history-log');
        const gameBoard = document.getElementById('game_board');
        const directionModal = document.getElementById('direction-modal');
        const historyModal = document.getElementById('history-modal');
        const openHistoryBtn = document.getElementById('open-history-btn');
        const closeHistoryModalBtn = document.getElementById('close-history-modal');
        const modalHistoryContent = document.getElementById('modal-history-content');
        let selectedPos = null;
        let currentRound = 0;

        const sleep = ms => new Promise(res => setTimeout(res, ms));

        function getEnabledRules() {
            const rules = [];
            if (document.getElementById('rule-e1')?.checked) rules.push('E1');
            if (document.getElementById('rule-e2')?.checked) rules.push('E2');
            if (document.getElementById('rule-e3')?.checked) rules.push('E3');
            if (document.getElementById('rule-e4')?.checked) rules.push('E4');
            if (document.getElementById('rule-e5')?.checked) rules.push('E5');
            return rules;
        }

        async function fetchAPI(endpoint, method = 'GET', body = null) {
            const options = { method, headers: { 'Content-Type': 'application/json' } };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
                updateStatus(`Error connecting to server.`);
                return null;
            }
        }

        function createBubbleElement(piece) {
            const bubble = document.createElement('div');
            bubble.className = `bubble ${piece.startsWith('p') ? 'peasant' : 'mandarin'} ${piece.endsWith('_a') ? 'bubble-a' : 'bubble-b'}`;
            if (piece.startsWith('m')) {
                bubble.textContent = 'üßô‚Äç‚ôÇÔ∏è';
            } else {
                bubble.textContent = 'üßë‚Äçüåæ';
            }
            return bubble;
        }

        function addBubbleToCell(cellElement, piece) {
            const bubble = createBubbleElement(piece);
            const size = piece.startsWith('p') ? 60 : 80;
            const padding = 5;
            bubble.style.left = `${padding + Math.random() * (cellElement.clientWidth - size - padding * 2)}px`;
            bubble.style.top = `${padding + Math.random() * (cellElement.clientHeight - size - padding * 2)}px`;
            cellElement.appendChild(bubble);
        }

        function renderBubbles(cellElement, pieces) {
            cellElement.innerHTML = '';
            pieces.forEach(piece => addBubbleToCell(cellElement, piece));
        }

        function updateStatus(message) { document.getElementById('game-status').textContent = message; }

        function addHistoryEntry(actionDetails, round, animationEvents) {
            const entry = document.createElement('div');
            entry.className = 'p-2 rounded border border-slate-600 text-sm';

            const moveAction = actionDetails.action || {};
            const reason = actionDetails.reason;

            let html = `<div class="flex justify-between items-center opacity-70"><span>Round ${round} - Player ${moveAction.pos ? moveAction.pos.charAt(0) : '?'}</span><span>${new Date().toLocaleTimeString()}</span></div><p class="font-semibold my-1">Move: ${moveAction.pos || 'N/A'} -> ${moveAction.way || 'N/A'}</p>`;

            if (reason) {
                html += `<p class="text-xs italic text-cyan-400 my-1">ü§î: ${reason}</p>`;
            }

            html += `<div class="text-xs opacity-80 pl-2 border-l-2 border-slate-500 max-h-24 overflow-y-auto">`;

            if (animationEvents) {
                let dropCounter = 0;
                animationEvents.forEach(event => {
                    switch (event.type) {
                        case 'pickup':
                            dropCounter = 0;
                            html += `<div><strong>B·ªëc ${event.pieces.length} qu√¢n</strong> t·ª´ √¥ ${event.pos}</div>`;
                            break;
                        case 'drop':
                            dropCounter++;
                            let pieceType = event.piece.startsWith('p') ? 'D√¢n' : 'Quan';
                            html += `<div>&nbsp;&nbsp;‚Ü≥ R·∫£i qu√¢n ${pieceType} #${dropCounter} t·ªõi √¥ ${event.to_pos}</div>`;
                            break;
                        case 'capture':
                            html += `<div><strong>ƒÇn ${event.pieces.length} qu√¢n</strong> ·ªü √¥ ${event.pos}</div>`;
                            break;
                        case 'game_over':
                            html += `<div class="font-bold text-red-400">${event.message}</div>`;
                            break;
                    }
                });
            } else if (actionDetails.steps) {
                actionDetails.steps.forEach(step => { html += `<div>${step}</div>`; });
            }

            html += `</div>`;
            entry.innerHTML = html;
            historyLog.prepend(entry);
        }

        function updateUI(data, skipBoardRendering = false) {
            if (!data || !data.game_state) return;
            const { game_state, game_over, winner, next_turn, action_details, animation_events } = data;
            const { board, score, round } = game_state;
            currentRound = round;
            document.getElementById('score-a').textContent = score.A;
            document.getElementById('score-b').textContent = score.B;
            if (!skipBoardRendering) {
                Object.keys(board).forEach(pos => {
                    const cell = document.getElementById(pos);
                    if (cell) {
                        renderBubbles(cell, board[pos]);
                        cell.classList.remove('ring-4', 'ring-offset-2', 'ring-purple-500', 'ring-yellow-500', 'ring-red-500');
                    }
                });
            }
            if (game_over) {
                updateStatus(`Game Over! Winner: ${winner}. (Round ${round})`);
                moveBtn.disabled = true;
                setHumanInteraction(false);
            } else {
                updateStatus(`Round ${round} - Turn: Player ${next_turn}`);
                moveBtn.disabled = data.human_turn === true;
            }
            if (action_details) addHistoryEntry(action_details, round, animation_events);
        }

        // --- Animation Logic (REVISED) ---
        async function animateEvents(events, finalState) {
            setHumanInteraction(false);
            moveBtn.disabled = true;
            resetBtn.disabled = true;
            applyConfigBtn.disabled = true;

            let lastHighlightedCell = null;
            let currentPickupPos = null;

            for (const event of events) {
                if (event.type === 'pickup') {
                    if (lastHighlightedCell) {
                        lastHighlightedCell.classList.remove('ring-4', 'ring-yellow-500');
                    }
                    currentPickupPos = event.pos;
                    const pickupCell = document.getElementById(event.pos);
                    if (pickupCell) {
                        pickupCell.classList.add('ring-4', 'ring-yellow-500');
                        lastHighlightedCell = pickupCell;
                        await sleep(400);
                    }
                } else if (event.type === 'drop') {
                    await animateSingleDrop(currentPickupPos, event.to_pos, event.piece);
                } else if (event.type === 'capture') {
                    await animateCapture(event.pos, event.team);
                } else if (event.type === 'score_update') {
                    document.getElementById('score-a').textContent = event.score.A;
                    document.getElementById('score-b').textContent = event.score.B;
                    await sleep(300);
                } else if (event.type === 'game_over') {
                    await sleep(500);
                    alert(event.message);
                }
            }

            updateUI(finalState, true);

            resetBtn.disabled = false;
            applyConfigBtn.disabled = false;
        }

        function getElementCenter(el) {
            const rect = el.getBoundingClientRect();
            return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        }

        async function animateSingleDrop(fromPos, toPos, piece) {
            const fromCell = document.getElementById(fromPos);
            const toCell = document.getElementById(toPos);
            if (!fromCell || !toCell) return;

            const bubbleToRemove = fromCell.querySelector('.bubble');
            let startRect;

            if (bubbleToRemove) {
                startRect = bubbleToRemove.getBoundingClientRect();
                fromCell.removeChild(bubbleToRemove);
            } else {
                const startCenter = getElementCenter(fromCell);
                startRect = { left: startCenter.x, top: startCenter.y, width: 0, height: 0 };
            }

            const endCenter = getElementCenter(toCell);

            const flyingBubble = createBubbleElement(piece);
            flyingBubble.classList.add('flying-bubble');
            document.body.appendChild(flyingBubble);

            flyingBubble.style.left = `${startRect.left}px`;
            flyingBubble.style.top = `${startRect.top}px`;

            await sleep(10);

            flyingBubble.style.left = `${endCenter.x - flyingBubble.offsetWidth / 2}px`;
            flyingBubble.style.top = `${endCenter.y - flyingBubble.offsetHeight / 2}px`;

            await sleep(250);
            document.body.removeChild(flyingBubble);

            addBubbleToCell(toCell, piece);
        }

        async function animateCapture(fromPos, team) {
            const fromCell = document.getElementById(fromPos);
            const scoreEl = document.getElementById(team === 'A' ? 'score-a' : 'score-b');

            fromCell.innerHTML = '';

            fromCell.classList.add('ring-4', 'ring-red-500', 'transition-all', 'duration-500');
            scoreEl.classList.add('scale-150', 'text-yellow-400', 'transition-all', 'duration-300');

            await sleep(500);

            fromCell.classList.remove('ring-4', 'ring-red-500');
            scoreEl.classList.remove('scale-150', 'text-yellow-400');
        }

        function setHumanInteraction(enable, availablePos = []) {
            gameBoard.classList.toggle('human-turn', enable);
            document.querySelectorAll('.game-cell').forEach(cell => {
                cell.classList.remove('selectable');
                cell.onclick = null;
            });
            if (enable) {
                updateStatus('Your turn! Please select a cell.');
                availablePos.forEach(pos => {
                    const cell = document.getElementById(pos);
                    if (cell) {
                        cell.classList.add('selectable');
                        cell.onclick = () => handleCellClick(pos);
                    }
                });
            }
        }

        function handleCellClick(pos) {
            selectedPos = pos;
            directionModal.classList.remove('hidden');
        }

        async function handleDirectionChoice(way) {
            directionModal.classList.add('hidden');
            setHumanInteraction(false);
            updateStatus(`Moving from ${selectedPos}...`);
            const data = await fetchAPI('/api/human_move', 'POST', { pos: selectedPos, way, extended_rule: getEnabledRules() });
            if (data && data.animation_events) {
                await animateEvents(data.animation_events, data);
            } else if (data) {
                updateUI(data);
            }
        }

        async function handleMove() {
            moveBtn.disabled = true;
            updateStatus('Thinking...');
            const data = await fetchAPI('/api/move', 'POST', { extended_rule: getEnabledRules() });
            if (data) {
                if (data.human_turn) {
                    updateUI(data);
                    setHumanInteraction(true, data.available_pos);
                } else if (data.animation_events) {
                    await animateEvents(data.animation_events, data);
                } else {
                    updateUI(data);
                }
            }
        }

        async function handleReset() {
            if (confirm('Are you sure you want to reset the game?')) {
                updateStatus('Resetting game...');
                const data = await fetchAPI('/api/reset', 'POST');
                if (data) {
                    historyLog.innerHTML = '';
                    modalHistoryContent.innerHTML = '';
                    updateUI(data);
                    alert('Game has been reset!');
                }
            }
        }

        async function handleApplyConfig() {

            // Th√™m c·∫£nh b√°o n·∫øu game ƒëang di·ªÖn ra
            if (currentRound > 0) {
                if (!confirm("Game s·∫Ω b·∫Øt ƒë·∫ßu l·∫°i n·∫øu b·∫°n thay ƒë·ªïi c√†i ƒë·∫∑t. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?")) {
                    return; // D·ª´ng n·∫øu ng∆∞·ªùi d√πng h·ªßy
                }
            }

            const player1Type = document.getElementById('player1').value;
            const player2Type = document.getElementById('player2').value;
            const settings = {
                player1: {
                    type: player1Type,
                    model: player1Type === 'agent' ? document.getElementById('model-select-1')?.value : null,
                    temperature: player1Type === 'agent' ? parseFloat(document.getElementById('temperature-value-1')?.value) : null,
                    maxTokens: player1Type === 'agent' ? parseInt(document.getElementById('max-tokens-value-1')?.value) : null,
                    topP: player1Type === 'agent' ? parseFloat(document.getElementById('top-p-value-1')?.value) : null,
                    thinkingMode: player1Type === 'agent' ? document.getElementById('thinking-mode-1')?.checked : null,
                },
                player2: {
                    type: player2Type,
                    model: player2Type === 'agent' ? document.getElementById('model-select-2')?.value : null,
                    temperature: player2Type === 'agent' ? parseFloat(document.getElementById('temperature-value-2')?.value) : null,
                    maxTokens: player2Type === 'agent' ? parseInt(document.getElementById('max-tokens-value-2')?.value) : null,
                    topP: player2Type === 'agent' ? parseFloat(document.getElementById('top-p-value-2')?.value) : null,
                    thinkingMode: player2Type === 'agent' ? document.getElementById('thinking-mode-2')?.checked : null,
                },
            };

            const response = await fetchAPI('/api/settings', 'POST', settings);
            if (response) {
                alert(response.message);
                historyLog.innerHTML = '';
                modalHistoryContent.innerHTML = '';
                updateUI(response);
                // Logic thu g·ªçn sidebar
                const sidebar = document.getElementById('sidebar');
                const sidebarContent = document.getElementById('sidebar-content-expanded');
                const expandBtn = document.getElementById('expand-sidebar-btn');
                if (sidebar && sidebarContent && expandBtn) {
                    sidebar.classList.remove('w-[20%]', 'p-4', 'pr-0');
                    sidebar.classList.add('w-16', 'p-2'); // Thu nh·ªè v√† gi·∫£m padding
                    sidebarContent.classList.add('hidden');
                    expandBtn.classList.remove('hidden');
                }
            }
        }

        function showHistoryModal() {
            modalHistoryContent.innerHTML = historyLog.innerHTML;
            historyModal.classList.remove('hidden');
        }
        function hideHistoryModal() { historyModal.classList.add('hidden'); }

        async function initialize() {
            updateStatus('Fetching initial game state...');
            const data = await fetchAPI('/api/state');
            if (data) updateUI(data);
        }
        function setupDirectionAnimationListeners() {
            const clockwiseBtn = document.querySelector('button[data-way="clockwise"]');
            const counterClockwiseBtn = document.querySelector('button[data-way="counter_clockwise"]');
            const animationOverlay = document.getElementById('animation-overlay');

            if (!clockwiseBtn || !counterClockwiseBtn || !animationOverlay) {
                console.error("L·ªói: Kh√¥ng t√¨m th·∫•y c√°c ph·∫ßn t·ª≠ c·ªßa animation.");
                return;
            }

            // Path g·ªëc, ch·∫°y NG∆Ø·ª¢C CHI·ªÄU kim ƒë·ªìng h·ªì (sang tr√°i)
            const originalPathData = "M 85,25 L 15,25 Q 5,25 5,35 L 5,65 Q 5,75 15,75 L 85,75 Q 95,75 95,65 L 95,35 Q 95,25 85,25 Z";

            // Path m·ªõi, ch·∫°y C√ôNG CHI·ªÄU kim ƒë·ªìng h·ªì (sang ph·∫£i)
            const newPathData = "M 85,25 Q 95,25 95,35 L 95,65 Q 95,75 85,75 L 15,75 Q 5,75 5,65 L 5,35 Q 5,25 15,25 L 85,25 Z";

            const arrowShape = "M0,-5 L10,0 L0,5 Z";

            const createDirectionalAnimation = (direction) => {
                const isClockwiseBtn = direction === 'clockwise';
                let pathForAnimation;

                // **LOGIC M·ªöI ƒê∆†N GI·∫¢N:** Ch·ªçn ƒë√∫ng path cho ƒë√∫ng n√∫t
                if (isClockwiseBtn) {
                    // N√∫t "C√πng chi·ªÅu" -> ch·∫°y sang TR√ÅI -> d√πng path ng∆∞·ª£c chi·ªÅu
                    pathForAnimation = newPathData;
                } else {
                    // N√∫t "Ng∆∞·ª£c chi·ªÅu" -> ch·∫°y sang PH·∫¢I -> d√πng path c√πng chi·ªÅu
                    pathForAnimation = originalPathData;
                }

                return `
                    <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <path d="${pathForAnimation}" fill="none" stroke="#f59e0b" stroke-width="1.5" stroke-dasharray="5 5" stroke-linecap="round"/>
                        
                        <path d="${arrowShape}" fill="#f59e0b">
                            <animateMotion
                                dur="5s"
                                repeatCount="indefinite"
                                path="${pathForAnimation}"
                                rotate="auto" 
                            />
                        </path>
                    </svg>
                `;
                // Ch√∫ √Ω: rotate="auto" v√† kh√¥ng c·∫ßn th√™m g√¨ kh√°c
            };

            // C√°c h√†m showAnimation, hideAnimation v√† event listeners gi·ªØ nguy√™n
            const showAnimation = (direction) => {
                animationOverlay.innerHTML = createDirectionalAnimation(direction);
                animationOverlay.classList.remove('hidden');
            };

            const hideAnimation = () => {
                animationOverlay.innerHTML = '';
                animationOverlay.classList.add('hidden');
            };

            clockwiseBtn.addEventListener('mouseenter', () => showAnimation('clockwise'));
            clockwiseBtn.addEventListener('mouseleave', hideAnimation);

            counterClockwiseBtn.addEventListener('mouseenter', () => showAnimation('counter_clockwise'));
            counterClockwiseBtn.addEventListener('mouseleave', hideAnimation);
        }

        function handleExpandSidebar() {
            const sidebar = document.getElementById('sidebar');
            const sidebarContent = document.getElementById('sidebar-content-expanded');
            const expandBtn = document.getElementById('expand-sidebar-btn');

            if (sidebar && sidebarContent && expandBtn) {
                sidebar.classList.add('w-[20%]', 'p-4', 'pr-0');
                sidebar.classList.remove('w-16', 'p-2');
                sidebarContent.classList.remove('hidden');
                expandBtn.classList.add('hidden');
            }
        }

        moveBtn.addEventListener('click', handleMove);
        resetBtn.addEventListener('click', handleReset);
        applyConfigBtn.addEventListener('click', handleApplyConfig);

        document.querySelectorAll('.direction-btn').forEach(btn => {
            btn.addEventListener('click', () => handleDirectionChoice(btn.dataset.way));
        });
        openHistoryBtn.addEventListener('click', showHistoryModal);
        closeHistoryModalBtn.addEventListener('click', hideHistoryModal);
        historyModal.addEventListener('click', (event) => {
            if (event.target === historyModal) hideHistoryModal();
        });
        setupDirectionAnimationListeners();

        // Th√™m s·ª± ki·ªán cho n√∫t expand
        const expandSidebarBtn = document.getElementById('expand-sidebar-btn');
        if (expandSidebarBtn) {
            expandSidebarBtn.addEventListener('click', handleExpandSidebar);
        }

        initialize();

        closeHistoryModalBtn.addEventListener('click', hideHistoryModal);
        document.getElementById('export-history-json').addEventListener('click', () => {
            const historyEntries = Array.from(modalHistoryContent.querySelectorAll('div.p-2'));

            const jsonHistory = historyEntries.map(entry => ({
                roundInfo: entry.querySelector('span')?.textContent?.trim() || "",
                time: entry.querySelectorAll('span')?.[1]?.textContent?.trim() || "",
                move: entry.querySelector('p.font-semibold')?.textContent?.trim() || "",
                reason: entry.querySelector('p.text-xs')?.textContent?.trim() || "",
                details: Array.from(entry.querySelectorAll('.border-l-2 > div')).map(div => div.textContent.trim())
            }));

            const blob = new Blob([JSON.stringify(jsonHistory, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `game_history_round${currentRound}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    });
</script>
{% endblock %}